{
  "applies": [
    {
      "apply_id": "59139655-01a6-46d5-9087-31c5b3ed8313",
      "timestamp": "2026-02-10T15:06:34Z",
      "status": "rolled_back",
      "full_snapshot": false,
      "pre_version": null,
      "post_version": null,
      "patches": [
        {
          "file": "components/partial_demo.py",
          "action": "create",
          "before_exists": false,
          "before_content": null
        }
      ],
      "results": [
        {
          "file": "components/partial_demo.py",
          "status": "success",
          "action": "create"
        }
      ],
      "rollback_timestamp": "2026-02-10T15:07:04Z",
      "rollback_files": null,
      "rollback_results": [
        {
          "file": "components/partial_demo.py",
          "status": "success",
          "action": "deleted"
        }
      ],
      "rollback_hot_reload": [
        {
          "component": "partial_demo",
          "success": false
        }
      ]
    },
    {
      "apply_id": "3bfa6251-53ad-4893-8167-4e31384d8b1c",
      "timestamp": "2026-02-10T15:19:50Z",
      "status": "applied",
      "full_snapshot": false,
      "pre_version": null,
      "post_version": null,
      "patches": [
        {
          "file": "components/partial_demo.py",
          "action": "replace",
          "before_exists": false,
          "before_content": null,
          "after_exists": true,
          "after_content": "from fastapi import FastAPI\n\ndef setup(mcp=None, app: FastAPI = None):\n    if app:\n        pass"
        }
      ],
      "results": [
        {
          "file": "components/partial_demo.py",
          "status": "success",
          "action": "replace"
        }
      ]
    },
    {
      "timestamp": "2026-02-10T16:17:36Z",
      "patches": [
        {
          "file": "temp_test_patch.txt",
          "action": "create",
          "content": "Hello from test!"
        }
      ]
    },
    {
      "timestamp": "2026-02-10T16:19:16Z",
      "patches": [
        {
          "file": "temp_test_patch.txt",
          "action": "create",
          "content": "Hello from test!"
        }
      ]
    },
    {
      "apply_id": "57178fe2-3b74-4ac7-ac9a-80eeced27e90",
      "timestamp": "2026-02-10T16:45:21Z",
      "status": "applied",
      "full_snapshot": false,
      "pre_version": null,
      "post_version": null,
      "patches": [
        {
          "file": "quota_server.py",
          "action": "create",
          "before_exists": true,
          "before_content": "import os\nimport uvicorn\nfrom fastapi import FastAPI, HTTPException, Body\nfrom pydantic import BaseModel\nfrom typing import Optional, Dict, Any, List, Tuple\nfrom redis_quota_manager import RedisQuotaManager\n\n# Initialize Core Manager\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nquota_manager = RedisQuotaManager(BASE_DIR)\n\napp = FastAPI(title=\"Quota Server (State Node)\")\n\nclass UpdateQuotaRequest(BaseModel):\n    model_name: str\n    tokens_used: int\n    request_count: int\n    config_file: Optional[str] = None\n\nclass BlockProviderRequest(BaseModel):\n    model_name: str\n    reason: str\n    config_file: Optional[str] = None\n\nclass ToggleRequest(BaseModel):\n    enabled: bool\n\n@app.get(\"/get_model_for_request\")\ndef get_model_for_request(preferred_model: Optional[str] = None):\n    model, config = quota_manager.get_model_for_request(preferred_model)\n    return {\"model\": model, \"config\": config}\n\n@app.post(\"/update_quota\")\ndef update_quota(req: UpdateQuotaRequest):\n    quota_manager.update_quota(req.model_name, req.tokens_used, req.request_count, req.config_file)\n    return {\"success\": True}\n\n@app.post(\"/mark_provider_blocked\")\ndef mark_provider_blocked(req: BlockProviderRequest):\n    quota_manager.mark_provider_blocked(req.model_name, req.reason, req.config_file)\n    return {\"success\": True}\n\n@app.get(\"/get_all_models\")\ndef get_all_models(page: int = 1, page_size: int = 50):\n    models = quota_manager.get_all_models()\n    total_count = len(models)\n    page = max(1, int(page))\n    page_size = max(1, int(page_size))\n    start = (page - 1) * page_size\n    end = start + page_size\n    return {\n        \"models\": models[start:end],\n        \"total_count\": total_count,\n        \"current_page\": page,\n        \"page_size\": page_size,\n    }\n\n@app.get(\"/get_speed_override\")\ndef get_speed_override():\n    return {\"enabled\": quota_manager.get_speed_override()}\n\n@app.post(\"/set_speed_override\")\ndef set_speed_override(req: ToggleRequest):\n    quota_manager.set_speed_override(req.enabled)\n    return {\"success\": True}\n\n@app.post(\"/sync_configuration\")\ndef sync_configuration():\n    quota_manager._sync_configuration_from_json()\n    return {\"success\": True}\n\n@app.get(\"/quotas\")\ndef list_quotas():\n    quota_dir = quota_manager.quota_dir\n    files = []\n    if os.path.exists(quota_dir):\n        files = [f for f in os.listdir(quota_dir) if f.endswith(\".json\")]\n    return {\"files\": files}\n\n@app.post(\"/quotas/upload\")\ndef upload_quota(file: dict = Body(...)):\n    # file content is passed as base64 or text?\n    # Simplified: accept text content and filename\n    filename = file.get(\"filename\")\n    content = file.get(\"content\")\n    \n    if not filename or not filename.endswith(\".json\"):\n        raise HTTPException(status_code=400, detail=\"Invalid filename\")\n        \n    file_path = os.path.join(quota_manager.quota_dir, filename)\n    try:\n        with open(file_path, \"w\") as f:\n            f.write(content)\n        quota_manager._sync_configuration_from_json()\n        return {\"success\": True, \"filename\": filename}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.delete(\"/quotas/{filename}\")\ndef delete_quota(filename: str):\n    if os.path.sep in filename or \"..\" in filename:\n         raise HTTPException(status_code=400, detail=\"Invalid filename\")\n\n    file_path = os.path.join(quota_manager.quota_dir, filename)\n    if not os.path.exists(file_path):\n        raise HTTPException(status_code=404, detail=\"File not found\")\n        \n    try:\n        os.remove(file_path)\n        quota_manager._sync_configuration_from_json()\n        return {\"success\": True}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/status\")\ndef status():\n    return {\"status\": \"running\", \"base_dir\": BASE_DIR}\n\nif __name__ == \"__main__\":\n    print(f\"\ud83e\udde0 Quota/State Server running on port 8003 (PID: {os.getpid()})\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8003, log_level=\"warning\")\n",
          "after_exists": true,
          "after_content": "import uvicorn\n\nimport os\nimport uvicorn\nfrom fastapi import FastAPI, HTTPException, Body\nfrom pydantic import BaseModel\nfrom typing import Optional, Dict, Any, List, Tuple\nfrom redis_quota_manager import RedisQuotaManager\nfrom components.ModelAndQuotaPagingAndFiltering import pagination_and_filtering_component\n\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nquota_manager = RedisQuotaManager(BASE_DIR)\napp = FastAPI(title=\"Quota Server (State Node)\")\n\nclass UpdateQuotaRequest(BaseModel):\n    model_name: str\n    tokens_used: int\n    request_count: int\n    config_file: Optional[str] = None\n\nclass BlockProviderRequest(BaseModel):\n    model_name: str\n    reason: str\n    config_file: Optional[str] = None\n\nclass ToggleRequest(BaseModel):\n    enabled: bool\n\napp.include_router(pagination_and_filtering_component)\n\n..."
        },
        {
          "file": "ui_server.py",
          "action": "create",
          "before_exists": true,
          "before_content": "import os\nimport shutil\nimport uvicorn\nimport json\nimport asyncio\nimport glob\nimport uuid\nimport re\nimport traceback\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import HTMLResponse, FileResponse, StreamingResponse\nfrom fastapi.concurrency import run_in_threadpool\nfrom contextlib import asynccontextmanager\nfrom pydantic import BaseModel\n\n# Imports for High-MCP\nfrom remote_quota_manager import RemoteQuotaManager\nfrom ai_engine import AIEngine\nfrom component_manager import ComponentManager\nfrom trust_system import TrustSystem\nfrom error_manager import ErrorManager\n\n# Global Instances\nquota_manager: Optional[Any] = None\nai_engine: Optional[AIEngine] = None\ncomponent_manager: Optional[ComponentManager] = None\n\n# We keep these for compatibility but they are not fully active in this node\nerror_manager = None\ntrust_system = None\npatch_history_lock = asyncio.Lock()\n\ndef _utc_now_iso() -> str:\n    return datetime.utcnow().replace(microsecond=0).isoformat() + \"Z\"\n\ndef _extract_fastapi_routes(source: Optional[str]) -> set[str]:\n    if not source:\n        return set()\n    pattern = re.compile(r\"@app\\.(?:get|post|put|delete|patch|websocket)\\(\\s*['\\\"]([^'\\\"]+)['\\\"]\")\n    return set(m.group(1) for m in pattern.finditer(source))\n\ndef _count_mcp_tools(source: Optional[str]) -> int:\n    if not source:\n        return 0\n    return len(re.findall(r\"@mcp\\.tool\\b\", source))\n\ndef _mentions_mcp_tools(source: Optional[str]) -> bool:\n    if not source:\n        return False\n    return \"@mcp.tool\" in source or \"mcp.tool(\" in source\n\ndef _restart_targets_for_path(rel_path: str) -> set[str]:\n    norm = (rel_path or \"\").replace(\"\\\\\", \"/\").lstrip(\"/\")\n    if norm in {\"ui_server.py\"}:\n        return {\"ui_node\"}\n    if norm in {\"server.py\"}:\n        return {\"mcp_node\"}\n    if norm in {\"ai_engine.py\", \"component_manager.py\", \"trust_system.py\"}:\n        return {\"ui_node\", \"mcp_node\"}\n    if norm.startswith(\"components/\") and norm.endswith(\".py\"):\n        return {\"ui_node\", \"mcp_node\"}\n    return set()\n\ndef _advice_summary(targets: set[str]) -> List[Dict[str, str]]:\n    out: List[Dict[str, str]] = []\n    if \"ui_node\" in targets:\n        out.append({\"server\": \"ui_node\", \"how\": \"Restart UI Node: uvicorn ui_server:app (port 8004)\"})\n    if \"mcp_node\" in targets:\n        out.append({\"server\": \"mcp_node\", \"how\": \"Restart MCP Node: python server.py (spawns UI node)\"})\n    return out\n\ndef _patch_history_path(base_dir: str) -> str:\n    return os.path.join(base_dir, \"trust_store\", \"patch_history.json\")\n\ndef _load_patch_history(base_dir: str) -> Dict[str, Any]:\n    path = _patch_history_path(base_dir)\n    if not os.path.exists(path):\n        return {\"applies\": []}\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        if isinstance(data, dict) and isinstance(data.get(\"applies\"), list):\n            return data\n    except Exception:\n        pass\n    return {\"applies\": []}\n\ndef _save_patch_history(base_dir: str, data: Dict[str, Any]):\n    trust_dir = os.path.join(base_dir, \"trust_store\")\n    os.makedirs(trust_dir, exist_ok=True)\n    path = _patch_history_path(base_dir)\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2)\n\nclass LocalQuotaManagerAsync:\n    def __init__(self, base_dir: str):\n        from redis_quota_manager import RedisQuotaManager\n        self.inner = RedisQuotaManager(base_dir)\n        self.quota_dir = self.inner.quota_dir\n\n    async def get_model_for_request(self, preferred_model: Optional[str] = None) -> Tuple[Optional[str], Dict[str, Any]]:\n        return await run_in_threadpool(self.inner.get_model_for_request, preferred_model)\n\n    async def update_quota(self, model_name: str, tokens_used: int, request_count: int = 1, config_file: Optional[str] = None):\n        await run_in_threadpool(self.inner.update_quota, model_name, tokens_used, request_count, config_file)\n\n    async def mark_provider_blocked(self, model_name: str, reason: str, config_file: Optional[str] = None):\n        await run_in_threadpool(self.inner.mark_provider_blocked, model_name, reason, config_file)\n\n    async def get_all_models(self) -> List[Dict[str, Any]]:\n        return await run_in_threadpool(self.inner.get_all_models)\n\n    async def get_speed_override(self) -> bool:\n        return await run_in_threadpool(self.inner.get_speed_override)\n\n    async def set_speed_override(self, enabled: bool):\n        await run_in_threadpool(self.inner.set_speed_override, enabled)\n\n    async def _sync_configuration_from_json(self):\n        await run_in_threadpool(self.inner._sync_configuration_from_json)\n\n    async def list_quotas(self) -> List[str]:\n        paths = glob.glob(os.path.join(self.quota_dir, \"*.json\"))\n        return [os.path.basename(p) for p in paths]\n\n    async def upload_quota(self, filename: str, content: str):\n        if os.path.sep in filename or \"..\" in filename:\n            raise ValueError(\"Invalid filename\")\n        file_path = os.path.join(self.quota_dir, filename)\n        def _write():\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n        await run_in_threadpool(_write)\n        await self._sync_configuration_from_json()\n\n    async def delete_quota(self, filename: str):\n        if os.path.sep in filename or \"..\" in filename:\n            raise ValueError(\"Invalid filename\")\n        file_path = os.path.join(self.quota_dir, filename)\n        def _delete():\n            if os.path.exists(file_path):\n                os.remove(file_path)\n        await run_in_threadpool(_delete)\n        await self._sync_configuration_from_json()\n\n    async def close(self):\n        await run_in_threadpool(self.inner.close)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    global quota_manager, ai_engine, component_manager, trust_system, error_manager\n    print(\"\ud83d\ude80 UI Node Starting...\")\n    \n    # Check if a Quota Server is running, if not, use RedisQuotaManager locally\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    \n    try:\n        # Try to connect to Quota Server\n        q = RemoteQuotaManager(base_url=\"http://localhost:8003\")\n        probe = await q.client.get(\"/status\")\n        probe.raise_for_status()\n        quota_manager = q\n        print(\"\u2705 Connected to Remote Quota Manager (Port 8003)\")\n    except Exception:\n        print(\"\u26a0\ufe0f  Remote Quota Manager unreachable. Falling back to Local RedisQuotaManager.\")\n        quota_manager = LocalQuotaManagerAsync(base_dir)\n    \n    ai_engine = AIEngine(quota_manager, base_dir=base_dir)\n    \n    # Initialize ComponentManager with App\n    trust_system = TrustSystem(base_dir)\n    error_manager = ErrorManager(base_dir, ai_engine=ai_engine, trust_system=trust_system)\n    print(\"\ud83e\udde9 Initializing Component Manager (UI Mode)...\")\n    component_manager = ComponentManager(base_dir, trust_system=trust_system, fastapi_app=app)\n    component_manager.load_all_components()\n    component_manager.start_watcher()\n    \n    yield\n    # Shutdown\n    print(\"\ud83d\uded1 UI Node Stopping...\")\n    if component_manager:\n        component_manager.stop_watcher()\n    close_fn = getattr(quota_manager, \"close\", None)\n    if callable(close_fn):\n        res = close_fn()\n        if asyncio.iscoroutine(res):\n            await res\n\n\napp = FastAPI(title=\"MCP Server Manager (UI Node)\", lifespan=lifespan)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=False,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nclass CoderGenerateRequest(BaseModel):\n    prompt: str\n    model: Optional[str] = None\n\n@app.post(\"/api/coder/generate_stream\")\nasync def coder_generate_stream(req: CoderGenerateRequest):\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n    \n    async def event_generator():\n        queue = asyncio.Queue()\n        \n        async def callback(msg):\n            await queue.put({\"type\": \"log\", \"message\": msg})\n            \n        async def run_generation():\n            try:\n                result = await ai_engine.generate_patch(req.prompt, req.model, progress_callback=callback)\n                await queue.put({\"type\": \"result\", \"data\": result})\n            except Exception as e:\n                traceback.print_exc()\n                await queue.put({\"type\": \"result\", \"data\": {\"error\": str(e), \"raw\": traceback.format_exc()}})\n            finally:\n                await queue.put(None) # Sentinel\n        \n        task = asyncio.create_task(run_generation())\n        \n        while True:\n            item = await queue.get()\n            if item is None:\n                break\n            yield f\"data: {json.dumps(item)}\\n\\n\"\n            \n    return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n\n\nclass ToggleRequest(BaseModel):\n    enabled: bool\n\nclass AutoFixConfig(BaseModel):\n    auto_fix_enabled: bool\n    schedule_interval_minutes: int\n    auto_apply_confidence_threshold: float\n\ndef _model_to_dict(model: BaseModel) -> dict:\n    dump = getattr(model, \"model_dump\", None)\n    if callable(dump):\n        return dump()\n    return model.dict()\n\n@app.get(\"/api/autofix/config\")\nasync def get_autofix_config():\n    if error_manager:\n        return dict(error_manager.config)\n    return _model_to_dict(AutoFixConfig(\n        auto_fix_enabled=False,\n        schedule_interval_minutes=60,\n        auto_apply_confidence_threshold=0.9,\n    ))\n\n@app.post(\"/api/autofix/config\")\nasync def set_autofix_config(cfg: AutoFixConfig):\n    if not error_manager:\n        raise HTTPException(status_code=503, detail=\"Error Manager not initialized\")\n    error_manager.update_config(_model_to_dict(cfg))\n    return {\"success\": True, \"config\": dict(error_manager.config)}\n\nclass RollbackRequest(BaseModel):\n    version_id: str\n\nclass ChatRequest(BaseModel):\n    model: str\n    message: str\n    images: Optional[List[dict]] = None\n\nclass TemplateRequest(BaseModel):\n    pattern: str\n    format_str: str\n    description: str = \"\"\n\n@app.get(\"/\")\nasync def get_dashboard():\n    \"\"\"Serve the dashboard UI.\"\"\"\n    dashboard_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"dashboard.html\")\n    if os.path.exists(dashboard_path):\n        return FileResponse(dashboard_path)\n    return HTMLResponse(\"<h1>Dashboard file not found</h1>\")\n\n@app.get(\"/dashboard\")\nasync def get_dashboard_alias():\n    return await get_dashboard()\n\n@app.get(\"/api/status\")\nasync def get_status(page: int = 1, page_size: int = 50):\n    \"\"\"Get current system status and models.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    speed_override = await quota_manager.get_speed_override()\n\n    models_raw = await quota_manager.get_all_models()\n    if isinstance(models_raw, dict):\n        models = models_raw.get(\"models\", [])\n        total_count = models_raw.get(\"total_count\", len(models))\n        current_page = models_raw.get(\"current_page\", page)\n        effective_page_size = models_raw.get(\"page_size\", page_size)\n    else:\n        all_models = list(models_raw or [])\n        total_count = len(all_models)\n        effective_page_size = max(1, int(page_size))\n        current_page = max(1, int(page))\n        start = (current_page - 1) * effective_page_size\n        end = start + effective_page_size\n        models = all_models[start:end]\n    \n    return {\n        \"models\": models,\n        \"total_count\": total_count,\n        \"current_page\": current_page,\n        \"page_size\": effective_page_size,\n        \"speed_override\": speed_override\n    }\n\n@app.post(\"/api/toggle_speed\")\nasync def toggle_speed(req: ToggleRequest):\n    \"\"\"Toggle the global speed override.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    await quota_manager.set_speed_override(req.enabled)\n    print(f\"\u26a1 UI: Speed Override set to {req.enabled}\")\n    return {\"success\": True, \"speed_override\": req.enabled}\n\n@app.post(\"/api/reload_config\")\nasync def reload_config():\n    \"\"\"Reloads quota configuration from JSON files.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    # Trigger sync\n    await quota_manager._sync_configuration_from_json()\n    print(\"\ud83d\udd04 UI: Configuration reloaded from disk\")\n    return {\"success\": True}\n\n@app.get(\"/api/quotas\")\nasync def list_quotas():\n    \"\"\"List all existing quota files.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    files = await quota_manager.list_quotas()\n    return {\"files\": files}\n\n@app.post(\"/api/quotas/upload\")\nasync def upload_quota(file: UploadFile = File(...)):\n    \"\"\"Upload a new quota JSON file.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    if not file.filename.endswith(\".json\"):\n        raise HTTPException(status_code=400, detail=\"Only JSON files are allowed\")\n    \n    try:\n        content = await file.read()\n        text_content = content.decode(\"utf-8\")\n        await quota_manager.upload_quota(file.filename, text_content)\n        \n        # Auto-reload config after upload\n        await quota_manager._sync_configuration_from_json()\n        print(f\"\ud83d\udcc2 UI: Uploaded {file.filename}\")\n        return {\"success\": True, \"filename\": file.filename}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.delete(\"/api/quotas/{filename}\")\nasync def delete_quota(filename: str):\n    \"\"\"Delete a quota file.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    try:\n        await quota_manager.delete_quota(filename)\n        # Auto-reload config after delete\n        await quota_manager._sync_configuration_from_json()\n        print(f\"\ud83d\uddd1\ufe0f  UI: Deleted {filename}\")\n        return {\"success\": True}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/api/chat\")\nasync def chat(req: ChatRequest):\n    \"\"\"Send a chat message to the AI.\"\"\"\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n    \n    try:\n        # Run async AI generation\n        # ai_engine.generate_content is async and now awaits quota calls too\n        response = await ai_engine.generate_content(req.model, req.message, req.images)\n        return {\"response\": response}\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/chat/models\")\nasync def get_chat_models():\n    \"\"\"Get available models for chat.\"\"\"\n    if not quota_manager:\n        raise HTTPException(status_code=503, detail=\"Quota Manager not initialized\")\n    \n    models_raw = await quota_manager.get_all_models()\n    if isinstance(models_raw, dict):\n        return {\"models\": models_raw.get(\"models\", [])}\n    return {\"models\": list(models_raw or [])}\n\n@app.get(\"/api/templates\")\nasync def list_templates():\n    \"\"\"List all registered templates.\"\"\"\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n    \n    await ai_engine._ensure_repo()\n    \n    # We need to expose templates from request_repo\n    # Currently request_repo.templates is a list of dicts with compiled regex objects\n    # We need to serialize them for the API\n    templates = []\n    for t in ai_engine.request_repo.templates:\n        templates.append({\n            \"id\": t.get(\"id\") ,\n            \"pattern\": t[\"pattern\"].pattern,\n            \"format\": t[\"format\"],\n            \"description\": t.get(\"description\", \"\")\n        })\n    return {\"templates\": templates}\n\n@app.post(\"/api/templates\")\nasync def add_template(req: TemplateRequest):\n    \"\"\"Add a new prompt template.\"\"\"\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n    \n    await ai_engine._ensure_repo()\n    \n    try:\n        await ai_engine.request_repo.add_template(req.pattern, req.format_str, req.description)\n        print(f\"\ud83e\udde9 UI: Added template '{req.pattern}'\")\n        return {\"success\": True}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# --- Placeholder Endpoints for Error/Version compatibility ---\n@app.get(\"/api/versions\")\nasync def list_versions():\n    if not trust_system:\n        raise HTTPException(status_code=503, detail=\"Trust System not initialized\")\n    trust_system._load_manifest()\n    return {\n        \"versions\": trust_system.manifest.get(\"versions\", []),\n        \"current_version\": trust_system.manifest.get(\"current_version\"),\n    }\n\n@app.post(\"/api/rollback\")\nasync def rollback_system(req: RollbackRequest):\n    if not trust_system:\n        raise HTTPException(status_code=503, detail=\"Trust System not initialized\")\n\n    ok = trust_system.rollback(req.version_id)\n    if not ok:\n        raise HTTPException(status_code=404, detail=f\"Rollback failed for {req.version_id}\")\n\n    reloaded = []\n    if component_manager:\n        for name in list(component_manager.loaded_components.keys()):\n            try:\n                if component_manager.reload_component(name):\n                    reloaded.append(name)\n            except Exception:\n                pass\n\n    return {\n        \"success\": True,\n        \"rolled_back_to\": req.version_id,\n        \"reloaded_components\": reloaded,\n        \"note\": \"If rollback modified ui_server.py or core modules, restart may be required.\",\n    }\n\n@app.get(\"/api/errors\")\nasync def get_errors():\n    if not error_manager:\n        return []\n    return await run_in_threadpool(error_manager.get_errors)\n\n@app.get(\"/api/patches\")\nasync def get_patches():\n    if not error_manager:\n        return []\n    return await run_in_threadpool(error_manager.get_patches)\n\n@app.post(\"/api/patches/{patch_id}/simulate\")\nasync def simulate_patch(patch_id: str):\n    if not error_manager:\n        raise HTTPException(status_code=503, detail=\"Error Manager not initialized\")\n    return await run_in_threadpool(error_manager.simulate_patch, patch_id)\n\n@app.post(\"/api/patches/{patch_id}/apply\")\nasync def apply_autofix_patch(patch_id: str):\n    if not error_manager:\n        raise HTTPException(status_code=503, detail=\"Error Manager not initialized\")\n    return await run_in_threadpool(error_manager.apply_patch, patch_id)\n\nclass CoderGenerateRequest(BaseModel):\n    prompt: str\n    model: Optional[str] = None\n\nclass CoderApplyRequest(BaseModel):\n    patches: List[dict]\n    full_snapshot: bool = False\n\nclass CoderRollbackRequest(BaseModel):\n    apply_id: str\n    files: Optional[List[str]] = None\n\nclass ComponentReloadRequest(BaseModel):\n    component_name: str\n\n@app.get(\"/api/components\")\nasync def list_components():\n    if not component_manager:\n        raise HTTPException(status_code=503, detail=\"Component Manager not initialized\")\n    return {\"components\": component_manager.list_components()}\n\n@app.post(\"/api/components/load\")\nasync def load_component(req: ComponentReloadRequest):\n    if not component_manager:\n        raise HTTPException(status_code=503, detail=\"Component Manager not initialized\")\n    ok = component_manager.load_component(req.component_name)\n    if ok:\n        return {\"success\": True, \"message\": f\"Component {req.component_name} loaded\"}\n    raise HTTPException(status_code=404, detail=f\"Component {req.component_name} failed to load (check logs)\")\n\n@app.post(\"/api/components/unload\")\nasync def unload_component(req: ComponentReloadRequest):\n    if not component_manager:\n        raise HTTPException(status_code=503, detail=\"Component Manager not initialized\")\n    ok = component_manager.unload_component(req.component_name)\n    if ok:\n        return {\"success\": True, \"message\": f\"Component {req.component_name} unloaded\"}\n    raise HTTPException(status_code=404, detail=f\"Component {req.component_name} failed to unload (check logs)\")\n\n@app.post(\"/api/components/reload\")\nasync def reload_component(req: ComponentReloadRequest):\n    \"\"\"Reloads a component by name.\"\"\"\n    if not component_manager:\n        raise HTTPException(status_code=503, detail=\"Component Manager not initialized\")\n    \n    success = component_manager.reload_component(req.component_name)\n    if success:\n        return {\"success\": True, \"message\": f\"Component {req.component_name} reloaded\"}\n    else:\n        raise HTTPException(status_code=404, detail=f\"Component {req.component_name} failed to reload (check logs)\")\n\n@app.post(\"/api/coder/generate\")\nasync def coder_generate(req: CoderGenerateRequest):\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n    try:\n        result = await ai_engine.generate_patch(req.prompt, req.model)\n        return result\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/api/coder/generate_stream\")\nasync def coder_generate_stream(req: CoderGenerateRequest):\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n\n    async def event_generator():\n        queue = asyncio.Queue()\n        \n        async def callback(msg):\n            await queue.put({\"type\": \"log\", \"message\": msg})\n\n        async def run_generation():\n            try:\n                # pass callback to generate_patch\n                result = await ai_engine.generate_patch(req.prompt, req.model, progress_callback=callback)\n                await queue.put({\"type\": \"result\", \"data\": result})\n            except Exception as e:\n                import traceback\n                traceback.print_exc()\n                await queue.put({\"type\": \"error\", \"message\": str(e)})\n            finally:\n                await queue.put(None) # Sentinel\n\n        # Start generation in background\n        asyncio.create_task(run_generation())\n\n        while True:\n            try:\n                item = await asyncio.wait_for(queue.get(), timeout=1.0)\n                if item is None:\n                    break\n                yield f\"data: {json.dumps(item)}\\\\n\\\\n\"\n            except asyncio.TimeoutError:\n                yield \": keep-alive\\\\n\\\\n\"\n\n    return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n\n\n@app.post(\"/api/coder/apply\")\nasync def coder_apply(req: CoderApplyRequest):\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n        \n    results = []\n    base_dir = ai_engine.base_dir\n    apply_id = str(uuid.uuid4())\n    pre_version = None\n    post_version = None\n    if trust_system and req.full_snapshot:\n        pre_version = trust_system.create_snapshot(f\"coder-apply:before:{apply_id}\")\n\n    history_patches: List[Dict[str, Any]] = []\n    \n    for patch in req.patches:\n        file_path = patch.get(\"file\")\n        action = patch.get(\"action\")\n        content = patch.get(\"content\")\n        \n        if not file_path:\n            results.append({\"file\": \"unknown\", \"status\": \"error\", \"message\": \"Missing file path\"})\n            continue\n            \n        full_path = os.path.join(base_dir, file_path)\n        \n        # Security check: Prevent traversing up\n        if not os.path.abspath(full_path).startswith(os.path.abspath(base_dir)):\n             results.append({\"file\": file_path, \"status\": \"error\", \"message\": \"Invalid file path (outside project)\"})\n             continue\n             \n        try:\n            before_exists = False\n            before_content = None\n            try:\n                with open(full_path, \"r\", encoding=\"utf-8\", errors=\"replace\") as f:\n                    before_content = f.read()\n                before_exists = True\n            except FileNotFoundError:\n                before_exists = False\n\n            if action == \"create\" or action == \"replace\":\n                if content is None:\n                    results.append({\"file\": file_path, \"status\": \"error\", \"message\": \"Missing content\"})\n                    continue\n                after_content = content\n                # Ensure directory exists\n                os.makedirs(os.path.dirname(full_path), exist_ok=True)\n                with open(full_path, 'w', encoding='utf-8') as f:\n                    f.write(content)\n                results.append({\"file\": file_path, \"status\": \"success\", \"action\": action})\n                history_patches.append({\n                    \"file\": file_path,\n                    \"action\": action,\n                    \"before_exists\": before_exists,\n                    \"before_content\": before_content,\n                    \"after_exists\": True,\n                    \"after_content\": after_content,\n                })\n                \n            elif action == \"delete\":\n                if os.path.exists(full_path):\n                    os.remove(full_path)\n                    results.append({\"file\": file_path, \"status\": \"success\", \"action\": \"deleted\"})\n                    history_patches.append({\n                        \"file\": file_path,\n                        \"action\": action,\n                        \"before_exists\": True,\n                        \"before_content\": before_content,\n                        \"after_exists\": False,\n                        \"after_content\": None,\n                    })\n                else:\n                    results.append({\"file\": file_path, \"status\": \"skipped\", \"message\": \"File not found\"})\n                    history_patches.append({\n                        \"file\": file_path,\n                        \"action\": action,\n                        \"before_exists\": False,\n                        \"before_content\": None,\n                        \"after_exists\": False,\n                        \"after_content\": None,\n                    })\n            elif action == \"search_replace\":\n                search = patch.get(\"search\")\n                replace = patch.get(\"replace\")\n                use_regex = bool(patch.get(\"regex\", False))\n                count = patch.get(\"count\", 0)\n\n                if not before_exists:\n                    results.append({\"file\": file_path, \"status\": \"error\", \"message\": \"File not found for search_replace\"})\n                    continue\n                if search is None or replace is None:\n                    results.append({\"file\": file_path, \"status\": \"error\", \"message\": \"Missing search or replace\"})\n                    continue\n\n                with open(full_path, \"r\", encoding=\"utf-8\", errors=\"replace\") as f:\n                    cur = f.read()\n\n                if use_regex:\n                    updated, n = re.subn(search, replace, cur, count=0 if int(count) <= 0 else int(count))\n                else:\n                    if int(count) <= 0:\n                        updated = cur.replace(search, replace)\n                        n = 0 if cur == updated else 1\n                    else:\n                        updated = cur\n                        n = 0\n                        for _ in range(int(count)):\n                            idx = updated.find(search)\n                            if idx < 0:\n                                break\n                            updated = updated[:idx] + replace + updated[idx + len(search):]\n                            n += 1\n\n                if updated == cur:\n                    results.append({\"file\": file_path, \"status\": \"error\", \"message\": \"No matches found\"})\n                    continue\n\n                with open(full_path, \"w\", encoding=\"utf-8\") as f:\n                    f.write(updated)\n\n                results.append({\"file\": file_path, \"status\": \"success\", \"action\": action, \"matches\": n})\n                history_patches.append({\n                    \"file\": file_path,\n                    \"action\": action,\n                    \"before_exists\": True,\n                    \"before_content\": before_content,\n                    \"after_exists\": True,\n                    \"after_content\": updated,\n                })\n            else:\n                results.append({\"file\": file_path, \"status\": \"error\", \"message\": f\"Unknown action: {action}\"})\n                \n        except Exception as e:\n            results.append({\"file\": file_path, \"status\": \"error\", \"message\": str(e)})\n\n    changed_components: List[str] = []\n    for patch in req.patches:\n        file_path = patch.get(\"file\") or \"\"\n        norm = file_path.replace(\"\\\\\", \"/\")\n        if norm.startswith(\"components/\") and norm.endswith(\".py\"):\n            name = os.path.basename(norm)[:-3]\n            if name and not name.startswith(\"_\"):\n                if name not in changed_components:\n                    changed_components.append(name)\n\n    reload_results = []\n    if component_manager:\n        for name in changed_components:\n            try:\n                ok = component_manager.reload_component(name)\n                reload_results.append({\"component\": name, \"success\": bool(ok)})\n            except Exception as e:\n                reload_results.append({\"component\": name, \"success\": False, \"error\": str(e)})\n\n    runtime_targets: set[str] = set()\n    runtime_reasons: List[Dict[str, Any]] = []\n\n    for hp in history_patches:\n        rel = (hp.get(\"file\") or \"\").replace(\"\\\\\", \"/\").lstrip(\"/\")\n        before_src = hp.get(\"before_content\")\n        after_src = hp.get(\"after_content\")\n\n        if rel in {\"ui_server.py\"}:\n            runtime_targets.add(\"ui_node\")\n            runtime_reasons.append({\"file\": rel, \"reason\": \"UI server code changed; running process will not reload automatically.\"})\n            continue\n\n        if rel in {\"server.py\"}:\n            runtime_targets.add(\"mcp_node\")\n            runtime_reasons.append({\"file\": rel, \"reason\": \"MCP launcher changed; requires MCP restart (will respawn UI node).\"})\n            continue\n\n        if rel in {\"ai_engine.py\", \"component_manager.py\", \"trust_system.py\"}:\n            runtime_targets.update({\"ui_node\", \"mcp_node\"})\n            runtime_reasons.append({\"file\": rel, \"reason\": \"Core module changed; both nodes import it.\"})\n            continue\n\n        if rel.startswith(\"components/\") and rel.endswith(\".py\"):\n            before_routes = _extract_fastapi_routes(before_src)\n            after_routes = _extract_fastapi_routes(after_src)\n\n            removed_routes = sorted(list(before_routes - after_routes))\n            added_routes = sorted(list(after_routes - before_routes))\n\n            if removed_routes:\n                runtime_targets.add(\"ui_node\")\n                runtime_reasons.append({\n                    \"file\": rel,\n                    \"reason\": \"FastAPI routes removed/changed; running app cannot unregister routes at runtime.\",\n                    \"removed_routes\": removed_routes,\n                })\n            if added_routes:\n                runtime_reasons.append({\n                    \"file\": rel,\n                    \"reason\": \"FastAPI routes added; hot reload should be sufficient for adding routes.\",\n                    \"added_routes\": added_routes,\n                })\n\n            if _mentions_mcp_tools(before_src) or _mentions_mcp_tools(after_src) or _count_mcp_tools(before_src) != _count_mcp_tools(after_src):\n                runtime_targets.add(\"mcp_node\")\n                runtime_reasons.append({\n                    \"file\": rel,\n                    \"reason\": \"MCP tools may have changed; MCP node does not hot-reload components from UI apply.\",\n                })\n\n    failed_reloads = [r for r in reload_results if not r.get(\"success\")]\n    if failed_reloads:\n        runtime_reasons.append({\n            \"reason\": \"One or more component reloads failed; fix the component and reload again.\",\n            \"hot_reload_failures\": failed_reloads,\n        })\n\n    if trust_system:\n        if req.full_snapshot:\n            post_version = trust_system.create_snapshot(f\"coder-apply:after:{apply_id}\")\n\n    async with patch_history_lock:\n        hist = _load_patch_history(base_dir)\n        hist[\"applies\"].append({\n            \"apply_id\": apply_id,\n            \"timestamp\": _utc_now_iso(),\n            \"status\": \"applied\",\n            \"full_snapshot\": bool(req.full_snapshot),\n            \"pre_version\": pre_version,\n            \"post_version\": post_version,\n            \"patches\": history_patches,\n            \"results\": results,\n        })\n        _save_patch_history(base_dir, hist)\n\n    return {\n        \"apply_id\": apply_id,\n        \"pre_version\": pre_version,\n        \"post_version\": post_version,\n        \"results\": results,\n        \"hot_reload\": reload_results,\n        \"runtime_advice\": {\n            \"restart_recommended\": len(runtime_targets) > 0,\n            \"restart_targets\": sorted(list(runtime_targets)),\n            \"restart_instructions\": _advice_summary(runtime_targets),\n            \"reasons\": runtime_reasons,\n            \"notes\": [\n                \"Hot reload is best-effort. Newly-added FastAPI routes are usually fine, but removed routes require a restart.\",\n                \"Restarting the MCP node (python server.py) also respawns the UI node (port 8004).\",\n            ],\n        },\n    }\n\n@app.get(\"/api/coder/history\")\nasync def coder_history(limit: int = 50):\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n    base_dir = ai_engine.base_dir\n    async with patch_history_lock:\n        hist = _load_patch_history(base_dir)\n    applies = list(hist.get(\"applies\", []))\n    applies = applies[-max(1, int(limit)):]\n    return {\"applies\": applies}\n\n@app.post(\"/api/coder/rollback\")\nasync def coder_rollback(req: CoderRollbackRequest):\n    if not ai_engine:\n        raise HTTPException(status_code=503, detail=\"AI Engine not initialized\")\n\n    base_dir = ai_engine.base_dir\n    async with patch_history_lock:\n        hist = _load_patch_history(base_dir)\n        entry = next((a for a in hist.get(\"applies\", []) if a.get(\"apply_id\") == req.apply_id), None)\n        if not entry:\n            raise HTTPException(status_code=404, detail=f\"apply_id not found: {req.apply_id}\")\n\n        patches = list(entry.get(\"patches\", []))\n        if req.files:\n            allow = set(req.files)\n            patches = [p for p in patches if p.get(\"file\") in allow]\n\n        rollback_results = []\n        for p in reversed(patches):\n            rel = p.get(\"file\") or \"\"\n            full_path = os.path.join(base_dir, rel)\n\n            if not os.path.abspath(full_path).startswith(os.path.abspath(base_dir)):\n                rollback_results.append({\"file\": rel, \"status\": \"error\", \"message\": \"Invalid file path (outside project)\"})\n                continue\n\n            before_exists = bool(p.get(\"before_exists\"))\n            before_content = p.get(\"before_content\")\n\n            try:\n                if not before_exists:\n                    if os.path.exists(full_path):\n                        os.remove(full_path)\n                        rollback_results.append({\"file\": rel, \"status\": \"success\", \"action\": \"deleted\"})\n                    else:\n                        rollback_results.append({\"file\": rel, \"status\": \"skipped\", \"message\": \"File already missing\"})\n                else:\n                    os.makedirs(os.path.dirname(full_path), exist_ok=True)\n                    with open(full_path, \"w\", encoding=\"utf-8\") as f:\n                        f.write(before_content or \"\")\n                    rollback_results.append({\"file\": rel, \"status\": \"success\", \"action\": \"restored\"})\n            except Exception as e:\n                rollback_results.append({\"file\": rel, \"status\": \"error\", \"message\": str(e)})\n\n        changed_components: List[str] = []\n        for p in patches:\n            rel = (p.get(\"file\") or \"\").replace(\"\\\\\", \"/\")\n            if rel.startswith(\"components/\") and rel.endswith(\".py\"):\n                name = os.path.basename(rel)[:-3]\n                if name and not name.startswith(\"_\") and name not in changed_components:\n                    changed_components.append(name)\n\n        reload_results = []\n        if component_manager:\n            for name in changed_components:\n                try:\n                    ok = component_manager.reload_component(name)\n                    reload_results.append({\"component\": name, \"success\": bool(ok)})\n                except Exception as e:\n                    reload_results.append({\"component\": name, \"success\": False, \"error\": str(e)})\n\n        runtime_targets: set[str] = set()\n        runtime_reasons: List[Dict[str, Any]] = []\n        for p in patches:\n            rel = (p.get(\"file\") or \"\").replace(\"\\\\\", \"/\").lstrip(\"/\")\n            before_src = p.get(\"before_content\")\n            after_src = p.get(\"after_content\")\n\n            if rel in {\"ui_server.py\"}:\n                runtime_targets.add(\"ui_node\")\n                runtime_reasons.append({\"file\": rel, \"reason\": \"UI server code rolled back; restart required to load old code.\"})\n                continue\n\n            if rel in {\"server.py\"}:\n                runtime_targets.add(\"mcp_node\")\n                runtime_reasons.append({\"file\": rel, \"reason\": \"MCP launcher rolled back; restart MCP node to load old code.\"})\n                continue\n\n            if rel in {\"ai_engine.py\", \"component_manager.py\", \"trust_system.py\"}:\n                runtime_targets.update({\"ui_node\", \"mcp_node\"})\n                runtime_reasons.append({\"file\": rel, \"reason\": \"Core module rolled back; both nodes import it.\"})\n                continue\n\n            if rel.startswith(\"components/\") and rel.endswith(\".py\"):\n                before_routes = _extract_fastapi_routes(before_src)\n                after_routes = _extract_fastapi_routes(after_src)\n                removed_routes = sorted(list(after_routes - before_routes))\n                if removed_routes:\n                    runtime_targets.add(\"ui_node\")\n                    runtime_reasons.append({\n                        \"file\": rel,\n                        \"reason\": \"Rollback removed routes that are already registered in memory; restart UI node to fully remove them.\",\n                        \"removed_routes\": removed_routes,\n                    })\n\n                before_tools = _count_mcp_tools(before_src)\n                after_tools = _count_mcp_tools(after_src)\n                if after_tools != before_tools or _mentions_mcp_tools(before_src) or _mentions_mcp_tools(after_src):\n                    runtime_targets.add(\"mcp_node\")\n                    runtime_reasons.append({\n                        \"file\": rel,\n                        \"reason\": \"Rollback may change MCP tool set; restart MCP node to fully sync tools.\",\n                    })\n\n        entry[\"status\"] = \"rolled_back\"\n        entry[\"rollback_timestamp\"] = _utc_now_iso()\n        entry[\"rollback_files\"] = req.files\n        entry[\"rollback_results\"] = rollback_results\n        entry[\"rollback_hot_reload\"] = reload_results\n        entry[\"rollback_runtime_advice\"] = {\n            \"restart_recommended\": len(runtime_targets) > 0,\n            \"restart_targets\": sorted(list(runtime_targets)),\n            \"restart_instructions\": _advice_summary(runtime_targets),\n            \"reasons\": runtime_reasons,\n        }\n        _save_patch_history(base_dir, hist)\n\n    return {\n        \"apply_id\": req.apply_id,\n        \"status\": \"rolled_back\",\n        \"results\": rollback_results,\n        \"hot_reload\": reload_results,\n        \"runtime_advice\": {\n            \"restart_recommended\": len(runtime_targets) > 0,\n            \"restart_targets\": sorted(list(runtime_targets)),\n            \"restart_instructions\": _advice_summary(runtime_targets),\n            \"reasons\": runtime_reasons,\n            \"notes\": [\n                \"File rollback is partial. In-memory registrations (FastAPI routes, MCP tools) may require restarts to fully undo.\",\n                \"Restarting the MCP node (python server.py) also respawns the UI node (port 8004).\",\n            ],\n        },\n    }\n\nif __name__ == \"__main__\":\n    # In multi-node, we expect this file to be run directly or via uvicorn CLI\n    # We default to port 8002 if run directly\n    print(\"\ud83d\udda5\ufe0f  UI Node starting on port 8002...\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8002)\n",
          "after_exists": true,
          "after_content": "from fastapi import FastAPI\nfrom fastapi.params import Depends\nfrom pydantic import BaseModel\nfrom typing import Optional, Dict, Any, List, Tuple\nfrom redis_quota_manager import RedisQuotaManager\nfrom components.ModelAndQuotaPagingAndFiltering import pagination_and_filtering_component\n\napp = FastAPI()\napp.include_router(pagination_and_filtering_component)\n..."
        },
        {
          "file": "components/ModelAndQuotaPagingAndFiltering.py",
          "action": "create",
          "before_exists": false,
          "before_content": null,
          "after_exists": true,
          "after_content": "from fastapi import FastAPI, Depends\nfrom fastapi.params import Depends\nfrom pydantic import BaseModel\nfrom typing import Optional, Dict, Any, List, Tuple\nfrom redis_quota_manager import RedisQuotaManager\n\napp = FastAPI()\n\nclass ModelRequest(BaseModel):\n    model_name: str\n\nclass PaginationRequest(BaseModel):\n    page: int\n    per_page: int\n\nclass FilterRequest(BaseModel):\n    model_name: Optional[str]\n\n\nrouter = FastAPI()\n\ndef get_model_for_request(model_request: ModelRequest, page_request: PaginationRequest,\n                          filter_request: FilterRequest = Depends()):\n    # perform pagination and filtering logic\n    pass\n\nrouter.include_router(app, prefix='/api/models', tags=['models'])\n..."
        },
        {
          "file": "components/ModelAndQuotaPagingAndFiltering.py",
          "action": "replace",
          "before_exists": true,
          "before_content": "from fastapi import FastAPI, Depends\nfrom fastapi.params import Depends\nfrom pydantic import BaseModel\nfrom typing import Optional, Dict, Any, List, Tuple\nfrom redis_quota_manager import RedisQuotaManager\n\napp = FastAPI()\n\nclass ModelRequest(BaseModel):\n    model_name: str\n\nclass PaginationRequest(BaseModel):\n    page: int\n    per_page: int\n\nclass FilterRequest(BaseModel):\n    model_name: Optional[str]\n\n\nrouter = FastAPI()\n\ndef get_model_for_request(model_request: ModelRequest, page_request: PaginationRequest,\n                          filter_request: FilterRequest = Depends()):\n    # perform pagination and filtering logic\n    pass\n\nrouter.include_router(app, prefix='/api/models', tags=['models'])\n...",
          "after_exists": true,
          "after_content": "from fastapi import FastAPI, Depends\nfrom fastapi.params import Depends\nfrom pydantic import BaseModel\nfrom typing import Optional, Dict, Any, List, Tuple\nfrom redis_quota_manager import RedisQuotaManager\n\napp = FastAPI()\n\nclass ModelRequest(BaseModel):\n    model_name: str\n\nclass PaginationRequest(BaseModel):\n    page: int\n    per_page: int\n\nclass FilterRequest(BaseModel):\n    model_name: Optional[str]\n\n\nrouter = FastAPI()\n\ndef get_model_for_request(model_request: ModelRequest, page_request: PaginationRequest,\n                          filter_request: FilterRequest = Depends()):\n\ndef get_all_models(page: int, per_page: int = 5, model_name: Optional[str] = None):\n    # perform pagination and filtering logic\n    pass\n\n\nrouter.include_router(app, prefix='/api/models', tags=['models'])\ndef get_quotas(page: int, per_page: int = 5, model_name: Optional[str] = None):\n    # perform pagination and filtering logic\n    pass\n\nrouter.include_router(app, prefix='/api/quotas', tags=['quotas'])"
        }
      ],
      "results": [
        {
          "file": "quota_server.py",
          "status": "success",
          "action": "create"
        },
        {
          "file": "ui_server.py",
          "status": "success",
          "action": "create"
        },
        {
          "file": "components/ModelAndQuotaPagingAndFiltering.py",
          "status": "success",
          "action": "create"
        },
        {
          "file": "components/ModelAndQuotaPagingAndFiltering.py",
          "status": "success",
          "action": "replace"
        }
      ]
    }
  ]
}